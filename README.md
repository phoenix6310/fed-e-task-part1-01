## 简答题
1. 
    - 结果：10
    - 原因：
        1. 由于i是var声明，for循环结束时有全局变量i，值为10
        2. 数组a中村的函数内有打印i，函数执行时自生执行上下文没有i，沿着作用域链查找，最终找到全局的i
2. 
    - 结果：报错
    - 原因：
        let 声明的变量不会发生变量提升，会在当前块中形成暂时性死区。打印未申明变量时报错
3. 
```
let minNum = 0

arr.map((item, index)=>{
    if(index===0 || minNum>item){
        minNum=item
    }
})
```
4. 
    1. var 声明的变量在js编译时会发生变量提升，let&const不会
    2. let const 不能声明同名变量
    3. var & let 声明的变量，值可以修改。const声明的变量的内存地址值不能修改
5. 
    - 结果：20
    - 原因：
        1. fn作为对象的方法使用时，fn执行上下文中的this是obj
        2. 箭头函数没有自己的this，指向外层函数中的this
6. 
    1. 作为对象独一无二的key，方便向对象扩展方法，不用担心命名冲突
    2. 作为对象的私有属性，通过特定的方法来访问此属性
7. js中引用类型的值赋值给其他变量时，这些变量指向同一内存地址，是浅拷贝
   深拷贝是指将引用类型的数据拷贝到一个新的内存地址再赋值给变量。使两个变量看起来一样，实际指向不同的堆内存地址
8. 
    - js是单线程的，耗时任务会阻塞页面的渲染，造成页面卡顿。用户体验不好。
    - EventLoop 将任务队列中的任务（异步回调）捞出，放到主线程执行
    - 像ajax/定时器等注册的回调属于宏任务，promise.then 注册的回调属于微任务。微任务优先于宏任务执行。js主线程的同步任务执行完毕后,通过EventLoop捞出微任务&宏任务
9. 
```
const promise = new Promise((ful,rej)=>{
    let a = 'hello'
    ful(a)
})
promise.then(res=>{
    let b = 'lagou'
    return res + b
}).then(res=>{
    let c = 'i love u'
    console.log(res+c)
})
```
10. ts 是js的超集，支持js，类型注解，es6。
11. 
    - 优点：
        1. 错误更早暴露
        2. 代码更智能，编码更准确
        3. 重构更牢靠
        4. 减少不必要的类型判断
    - 缺点：
        有新概念
